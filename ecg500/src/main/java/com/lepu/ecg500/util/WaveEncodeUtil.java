package com.lepu.ecg500.util;import android.util.Log;import com.lepu.ecg500.entity.EcgSettingConfigEnum;/** * Created by wxd on 2019-03-29. */public class WaveEncodeUtil {    /**     * 增加计算的的导联数据     * I II v1 v2 v3 v4 v5 v6     * false I II III avr avl avf v1 v2 v3 v4 v5 v6     * true avl I -avr II avf III v1 v2 v3 v4 v5 v6     *     * @param signals     采集的原始数据，8导联或14导联     * @param cabreraMode false 标准模式；true 特殊模式     * @return     */    public static short[][] leadDataSwitch(short[][] signals, boolean cabreraMode, EcgSettingConfigEnum.LeadType leadType, boolean addPacemaker) {        if (signals == null) {            return null;        }        boolean calculateOtherLead = true;        short[] leadOffArray = signals[signals.length - 1];        if(leadOffArray.length-2 > 0){            for (int i = leadOffArray.length-2; i < leadOffArray.length; i++) {                short leadOffValue = leadOffArray[i];                // TODO: 2021/5/12 mwj DetectManager里面的方法抽取出来                char[] leadoffArray =  getLeadOffArray(leadOffValue);                char itemLA = leadoffArray[0];//LA                char itemLL = leadoffArray[1];//LL/F                //0 正常 ；1 脱落                if (itemLA == '1' || itemLL == '1') {                    calculateOtherLead = false;                }                break;            }        }        short[] lead3Array = new short[signals[0].length];        short[] leadAVRArray = new short[signals[0].length];        short[] leadAVLArray = new short[signals[0].length];        short[] leadAVFArray = new short[signals[0].length];        for (int j = 0; j < signals[0].length; j++) {            //111（II-I）            short lead3Value = 0;            //avr(-0.5*(1+11))            short leadAVRValue = 0;            //avl(0.5*(1-II+I))            short leadAVLValue = 0;            //avf(0.5*(11+II-I))            short leadAVFValue = 0;            if (calculateOtherLead) {                //111（II-I）                lead3Value = (short) (signals[1][j] - signals[0][j]);                //avr(-0.5*(1+11))                leadAVRValue = (short) (-(signals[0][j] + signals[1][j]) >> 1);                //avl(0.5*(1-II+I))                leadAVLValue = (short) (signals[0][j] - (signals[1][j] >> 1));                //avf(0.5*(11+II-I))                leadAVFValue = (short) (signals[1][j] - (signals[0][j] >> 1));            }            lead3Array[j] = lead3Value;            if (cabreraMode) {                leadAVRArray[j] = (short) (0 - leadAVRValue);            } else {                leadAVRArray[j] = leadAVRValue;            }            leadAVLArray[j] = leadAVLValue;            leadAVFArray[j] = leadAVFValue;        }        //+4 由于计算了4个导联        int calculateLeadNum = 0;        switch (leadType) {            case LEAD_9:                calculateLeadNum = 9;                break;            case LEAD_12:                calculateLeadNum = 12;                break;            case LEAD_15_STANDARD_RIGHT:            case LEAD_15_STANDARD_AFTER:            case LEAD_15_CHILD:                calculateLeadNum = 15;                break;            case LEAD_18:                calculateLeadNum = 18;                break;            default:                break;        }        short[][] dataArray = new short[calculateLeadNum][signals[0].length];        for (int i = 0; i < dataArray.length; i++) {            if (i == 0) {                if (cabreraMode) {                    //avL                    System.arraycopy(leadAVLArray, 0, dataArray[i], 0, signals[0].length);                } else {                    //I                    System.arraycopy(signals[i], 0, dataArray[i], 0, signals[0].length);                }            } else if (i == 1) {                if (cabreraMode) {                    //I                    System.arraycopy(signals[0], 0, dataArray[i], 0, signals[0].length);                } else {                    //II                    System.arraycopy(signals[i], 0, dataArray[i], 0, signals[0].length);                }            } else if (i == 2) {                if (cabreraMode) {                    //-avr                    System.arraycopy(leadAVRArray, 0, dataArray[i], 0, signals[0].length);                } else {                    //III                    System.arraycopy(lead3Array, 0, dataArray[i], 0, signals[0].length);                }            } else if (i == 3) {                if (cabreraMode) {                    //II                    System.arraycopy(signals[1], 0, dataArray[i], 0, signals[0].length);                } else {                    //aVR                    System.arraycopy(leadAVRArray, 0, dataArray[i], 0, signals[0].length);                }            } else if (i == 4) {                if (cabreraMode) {                    //avf                    System.arraycopy(leadAVFArray, 0, dataArray[i], 0, signals[0].length);                } else {                    //aVL                    System.arraycopy(leadAVLArray, 0, dataArray[i], 0, signals[0].length);                }            } else if (i == 5) {                if (cabreraMode) {                    //III                    System.arraycopy(lead3Array, 0, dataArray[i], 0, signals[0].length);                } else {                    //aVF                    System.arraycopy(leadAVFArray, 0, dataArray[i], 0, signals[0].length);                }            } else if (i >= 6) {                //胸导联                switch (leadType) {                    case LEAD_9:                        //V1 V3 V5                        if (i == 6) {                            System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        } else if (i == 7) {                            System.arraycopy(signals[i - 4 + 1], 0, dataArray[i], 0, signals[0].length);                        } else if (i == 8) {                            System.arraycopy(signals[i - 4 + 2], 0, dataArray[i], 0, signals[0].length);                        } else {                            //没了                        }                        break;                    case LEAD_12:                        System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        break;                    case LEAD_15_STANDARD_RIGHT:                        if (i >= 12 && i <= 14) {                            //V3R V4R V5R                            System.arraycopy(signals[i - 4 + 3], 0, dataArray[i], 0, signals[0].length);                        }else {                            //v1-v6                            System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        }                        break;                    case LEAD_15_STANDARD_AFTER:                        //v1-v6     V7 V8 V9                        System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        break;                    case LEAD_15_CHILD:                        //V3R V4R V7                        if (i == 12 || i == 13) {                            //v3r v4r                            System.arraycopy(signals[i - 4 + 3], 0, dataArray[i], 0, signals[0].length);                        }else if (i == 14) {                            //v7   8开始是v7                            System.arraycopy(signals[8], 0, dataArray[i], 0, signals[0].length);                        } else {                            //v1-v6                            System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        }                        break;                    case LEAD_18:                        //v1-v6     v3R-v5R     v7-v9                        if(i < 12){                            System.arraycopy(signals[i - 4], 0, dataArray[i], 0, signals[0].length);                        }else if (i >= 12 && i <= 14) {                            System.arraycopy(signals[i - 4 + 3], 0, dataArray[i], 0, signals[0].length);                        }  else {                            System.arraycopy(signals[8 + i-15], 0, dataArray[i], 0, signals[0].length);                        }                        break;                    default:                        break;                }            }        }        //添加起搏丁        short valueMv1 = (short) (Const.MV_1_SHORT);        dataArray = modifyPacePluse(dataArray, dataArray.length,signals[signals.length-1], signals[signals.length - 2], valueMv1,addPacemaker);        return dataArray;    }    /**     * 解析导联脱落     * @param leadOffValue     * @return  顺序 L F V1-V5R     */    public static char[] getLeadOffArray(short leadOffValue){        //自己增加了RL RA        //V5R V4R V3R V9 V8	V7 V6	V5	V4	V3	V2	V1	F/LL L 反转位置        //1为脱落，0为不脱落，当全为1时，说明所有导联都脱落，包括R在内        byte[] tempArray = Util.shortToByteArray(leadOffValue, true);        String flag0 = Util.toBinaryString(tempArray[0]);        String flag1 = Util.toBinaryString(tempArray[1]);        StringBuilder sb = new StringBuilder();        sb.append(flag0).reverse();        sb.append(new StringBuilder(flag1).reverse());        char[] leadoffArray = sb.toString().toCharArray();        return leadoffArray;    }    /**     * src     * x=0.61*V4+0.171*V3+0.781*V1     * y=0.655*(-V1+((II+III)/3)) + 0.345*V5 - V6     * z=0.133*V4 + 0.736*V5 - 0.264*V1-0.374*V2-0.231*V3 用这个     * <p>     * new1     * Wilson转Frank导联新计算公式：     * x=0.61*V4+0.171*V3-0.781*V1     * y=0.345V5-V6+0.655（2Ⅱ-Ⅰ）/3     * z=0.133*V4 + 0.736*V5 - 0.264*V1-0.374*V2-0.231*V3     *     * @param signals 采集的原始数据     * @return     */    public static short[][] leadDataSwitchXYZ(short[][] signals) {        if (signals == null) {            return null;        }        int leadDataLen = signals[0].length;        boolean calculateOtherLead = true;        boolean sameI = false;        boolean sameII = false;        for (int i = 0; i < signals[0].length; i++) {            int z = i + 1;            if (signals[0][i] != signals[0][z]) {                sameI = false;                break;            }            if (signals[1][i] != signals[1][z]) {                sameII = false;                break;            }            if (i + 1 + 1 == signals[0].length) {                break;            }        }        if (sameI || sameII) {            //有导联脱落            calculateOtherLead = false;        }        short[] lead3Array = new short[leadDataLen];        for (int j = 0; j < leadDataLen; j++) {            //111（II-I）            short lead3Value = 0;            if (calculateOtherLead) {                //111（II-I）                lead3Value = (short) (signals[1][j] - signals[0][j]);            }            lead3Array[j] = lead3Value;        }        //x,y,z        short[][] dataArray = new short[3][leadDataLen];        for (int i = 0; i < dataArray.length; i++) {            short[] tempValueArray = new short[leadDataLen];            if (i == 0) {                //x=0.61*V4+0.171*V3-0.781*V1                for (int j = 0; j < leadDataLen; j++) {                    tempValueArray[j] = (short) (0.61 * signals[5][j] + 0.171 * signals[4][j] - 0.781 * signals[2][j]);                }                dataArray[i] = tempValueArray;            } else if (i == 1) {                //y=0.345V5-V6+0.655（2Ⅱ-Ⅰ）/3                for (int j = 0; j < leadDataLen; j++) {                    tempValueArray[j] = (short) (0.345 * signals[6][j] - signals[7][j] + 0.655 * (2 * signals[1][j] - signals[0][j]) / 3);                }                dataArray[i] = tempValueArray;            } else if (i == 2) {                //z=0.133*V4 + 0.736*V5 - 0.264*V1-0.374*V2-0.231*V3                for (int j = 0; j < leadDataLen; j++) {                    tempValueArray[j] = (short) (0.133 * signals[5][j] + 0.736 * signals[6][j] - 0.264 * signals[2][j] - 0.374 * signals[3][j] - 0.231 * signals[4][j]);                }                dataArray[i] = tempValueArray;            } else {                break;            }        }        return dataArray;    }    /**     * 12 导联 特征波形（short * 1.2秒 * 采样率1000 *12）     * I  II III avL aVR aVF V1 V2 V3 V4 V5 V6     *     * @param dataArray     * @return     */    public static short[][] getEcgDataArrayAiAnalysisWaveForm(byte[] dataArray, int receiveLeadNum) {        short[][] ecgDataArray = new short[receiveLeadNum][1200];//ai 返回的特征波形是12导联数据        if (dataArray == null) {            return ecgDataArray;        }        try {            byte[] destArray = new byte[2];            int startIndex = 0;            for (int i = 0; i < ecgDataArray.length; i++) {                for (int j = 0; j < ecgDataArray[0].length; j++) {                    System.arraycopy(dataArray, startIndex, destArray, 0, destArray.length);                    ecgDataArray[i][j] = FormatTransfer.lBytesToShort(destArray);                    startIndex += destArray.length;                }            }            //外边分析时，已经转过了//            short[] avl = ecgDataArray[3];//            short[] avr = ecgDataArray[4];////            ecgDataArray[3] = avr;//            ecgDataArray[4] = avl;        } catch (Exception e) {            CustomTool.e(Log.getStackTraceString(e));        }        return ecgDataArray;    }    public static byte[] getEcgDataArrayAiAnalysisWaveForm(short[][] dataArray) {        byte[] destArray = new byte[dataArray.length * dataArray[0].length * 2];        int startIndex = 0;        byte[] srcArray;        for (int i = 0; i < dataArray.length; i++) {            for (int j = 0; j < dataArray[0].length; j++) {                short value = dataArray[i][j];                srcArray = FormatTransfer.toLH(value);                System.arraycopy(srcArray, 0, destArray, startIndex, srcArray.length);                startIndex += srcArray.length;            }        }        return destArray;    }    public static float[][] switchEcgDataArray(short[][] dataArray) {        if (dataArray == null) {            return null;        }        float[][] valueDataArray = new float[dataArray.length][dataArray[0].length];        for (int i = 0; i < dataArray.length; i++) {            for (int j = 0; j < dataArray[0].length; j++) {                short value = dataArray[i][j];                valueDataArray[i][j] = value * Const.SHORT_MV_GAIN;            }        }        return valueDataArray;    }    public static short[][] switchEcgDataArray(float[][] dataArray) {        short[][] valueDataArray = new short[dataArray.length][dataArray[0].length];        for (int i = 0; i < dataArray.length; i++) {            for (int j = 0; j < dataArray[0].length; j++) {                float value = dataArray[i][j];                valueDataArray[i][j] = (short) (value / Const.SHORT_MV_GAIN);            }        }        return valueDataArray;    }//    /**//     * 降采样，有点问题//     *//     * @param ecgDataArray//     * @param srcSampleRate//     * @param targetSampleRate//     * @return//     *///    public static short[][] resample(short[][] ecgDataArray, int srcSampleRate, int targetSampleRate) {//        int extra = srcSampleRate / targetSampleRate;//        int dataLenTemp = ecgDataArray[0].length;//        int outDataLen = dataLenTemp / extra;////        float[][] mvDataArrayTemp = new float[ecgDataArray.length][outDataLen];//        float[] mvDataArray = new float[dataLenTemp];//        NotifyResampleBean notifyResampleBean = new NotifyResampleBean();////        int notifyDataLen = 0;//        for (int k = 0; k < ecgDataArray.length; k++) {//            for (int i = 0; i < dataLenTemp; i++) {//                //mvDataArray[i] = ecgDataArray[k][i] * Const.SHORT_MV_GAIN;//                mvDataArray[i] = ecgDataArray[k][i] / 1000F * 200;//            }////            notifyResampleBean.setResampleDataArray(mvDataArrayTemp[k]);//            notifyResampleBean.setDataLen(mvDataArrayTemp[k].length);////            JniResample.getInstance().resample(mvDataArray, dataLenTemp, srcSampleRate,//                    targetSampleRate, notifyResampleBean);//            mvDataArrayTemp[k] = notifyResampleBean.getResampleDataArray();//            notifyDataLen = notifyResampleBean.getDataLen();//        }//        CustomTool.e(String.format("原始长度:%d,重采样长度:%d,返回长度:%d", dataLenTemp, outDataLen, notifyDataLen));////        return WaveEncodeUtil.switchEcgDataArray(mvDataArrayTemp);//    }    /**     * 降采样，有点问题     *     * @param ecgDataArray     * @param srcSampleRate     * @param targetSampleRate     * @return     */    public static short[][] resampleNew(short[][] ecgDataArray, int srcSampleRate, int targetSampleRate) {        int extra = srcSampleRate / targetSampleRate;//1000/500=2        int dataLenTemp = ecgDataArray[0].length;//101        int outDataLenExtra = dataLenTemp % extra;//1        int outDataLen = dataLenTemp / extra + outDataLenExtra;//101/2 + 1        short[][] outEcgDataArray = new short[ecgDataArray.length][outDataLen];        int tempCount = outDataLen;        if (outDataLenExtra > 0){            tempCount -= outDataLenExtra;        }        for (int k = 0; k < ecgDataArray.length; k++) {            for (int i = 0; i < tempCount; i++) {                outEcgDataArray[k][i] = ecgDataArray[k][i * 2];            }            if (outDataLenExtra > 0) {                outEcgDataArray[k][outDataLen - 1] = ecgDataArray[k][dataLenTemp - 1];            }        }        return outEcgDataArray;    }    /**     * 清理起搏脉冲     * L 脱落硬件能检测到起搏。F脱落，硬件检测不到起搏     * @param ecgDataArraySrc     * @param leadNum             原始数据通道     * @param ecgDataArraySrcPace     * @param resetMvValue        需要赋值的值     * @return     */    public static short[][] modifyPacePluse(short[][] ecgDataArraySrc, int leadNum, short[] ecgDataArraySrcLeadOff, short[] ecgDataArraySrcPace, short resetMvValue,boolean addPacemaker) {        //清理数据前后几个点        int dataCountPace = ecgDataArraySrcPace.length;        int clearDataCount = 2;//前后各几个点        int beginPos;        int endPos;        int checkPos;        short copyMvValue;        boolean paceFlag = false;        boolean logFlag = false;        boolean flagClearPaceData = resetMvValue == 0;        int foundPaceCount = 0;        int paceValue = -1;        for (int paceIndex = 0; paceIndex < dataCountPace; paceIndex++) {            //有起搏脉冲            if (ecgDataArraySrcPace[paceIndex] > 0) {                paceValue = ecgDataArraySrcPace[paceIndex];                paceFlag = true;                checkPos = paceIndex;                foundPaceCount ++;                if (checkPos - clearDataCount >= 0) {                    beginPos = checkPos - clearDataCount;                } else {                    beginPos = 0;                    if(flagClearPaceData && !logFlag){                        logFlag = true;                        CustomTool.d( "实时采集模式，左边界有脉冲信号");                    }                }                if (checkPos + clearDataCount >= dataCountPace) {                    endPos = dataCountPace - 1;                    if(flagClearPaceData && !logFlag){                        logFlag = true;                        CustomTool.d( "实时采集模式，右边界有脉冲信号");                    }                } else {                    endPos = (checkPos + clearDataCount);                }                //检查导联脱落                short leadOffValue = ecgDataArraySrcLeadOff[paceIndex];                // TODO: 2021/5/12 mwj DetectManager里面的方法抽取出来                char[] leadoffArray =  getLeadOffArray(leadOffValue);                char leadOff;                for (int channel = 0; channel < leadNum; channel++) {                    if (resetMvValue == 0) {                        //0 代表赋值为基线位置                        //需要找一下基线的值，再去赋值基线的值                        copyMvValue = ecgDataArraySrc[channel][beginPos];//不能用0，否则如果脱落，波形就出问题了                    } else {                        //不加起搏丁，中止                        if(!addPacemaker){                            break;                        }                        //不是调到基线，直接赋值                        //对应通道，导联脱落，可以不加起搏丁                        char leadOffL = leadoffArray[0];//L         代表I                        char leadOffF = leadoffArray[1];//F/LL      代表II                        if(leadOffL == '0' && leadOffF == '0'){                            //L F 都正常                            if(channel < 6){                                //肢体导联                                copyMvValue = resetMvValue;                            }else{                                if(channel >= 6 && channel < 12) {                                    //v1 - v6  胸导联                                    leadOff = leadoffArray[channel - 4];                                }else if(channel >= 12 && channel < 15){                                    //V3R V4R V5R                                    leadOff = leadoffArray[channel - 4 + 3];                                }else{                                    //V7 V8 V9                                    leadOff = leadoffArray[channel - 4 - 3];                                }                                if (leadOff == '0') {                                    //导联正常，才加起搏丁                                    copyMvValue = resetMvValue;                                } else {                                    copyMvValue = ecgDataArraySrc[channel][beginPos];                                }                            }                        }else if(leadOffL == '0'){                            //L 脱落硬件能检测到起搏。F脱落，硬件检测不到起搏                            if(channel == 0){                                copyMvValue = resetMvValue;                            }else{                                copyMvValue = ecgDataArraySrc[channel][beginPos];                            }                        }else{                            if(channel == 1){                                copyMvValue = resetMvValue;                            }else{                                copyMvValue = ecgDataArraySrc[channel][beginPos];                            }                        }                    }                    for (int i = beginPos; i <= endPos; i++) {                        ecgDataArraySrc[channel][i] = copyMvValue;                    }                }            }        }        //L F 脱落，硬件就检测不到起搏了        if(paceFlag){            CustomTool.d( String.format("检测到有起搏,起搏值：%d",paceValue));        }        // TODO: 2021/5/12 mwj 不用保存到本地//        if(flagClearPaceData){//            //实时采集模式//            if(foundPaceCount > 1){//                String message = String.format("异常1个包里出现多个起搏丁，采样个数:%s,发现起搏标记个数:%d",dataCountPace,foundPaceCount);//                Utils.writeSdLog(BaseApplication.getInstance(),Const.TAG_MONITOR,message);////                if(dataCountPace < 200){//                    String logData = Utils.getStringByShortArray(ecgDataArraySrcPace,false);//                    Utils.writeSdLog(BaseApplication.getInstance(),Const.TAG_MONITOR,logData);//                }//            }//        }        return ecgDataArraySrc;    }}